1）open(filename, mode) 
filename：filename 变量是一个包含了你要访问的文件名称的字符串值。
mode：mode决定了打开文件的模式：只读，写入，追加等。这个参数是非强制的，默认文件访问模式为只读(r)。

不同模式打开文件的完全列表：
模式	描述

r	以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。

rb	以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。

r+	打开一个文件用于读写。文件指针将会放在文件的开头。

rb+	以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。

w	打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。

wb	以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。

w+	打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。

wb+	以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。

a	打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件进行写入。

ab	以二进制格式打开一个文件用于追加。其它同上

a+	打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。
	如果该文件不存在，创建新文件用于读写。

ab+	以二进制格式打开一个文件用于追加。其它同上


模式		r	r+	w	w+	a	a+

读		+	+		+		+

写			+	+	+	+	+

创建				+	+	+	+

覆盖				+	+		

指针在开始	+	+	+	+		
	
指针在结尾					+	+

迭代一个文件对象然后读取每行:
#!/usr/bin/python3

# 打开一个文件
f = open("/tmp/foo.txt", "r")

for line in f:
    print(line, end='')

# 关闭打开的文件
f.close()




2）read(size)  这将读取一定数目的数据, 然后作为字符串或字节对象返回。
size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。
f = open("/tmp/foo.txt", "r")

str = f.read()
print(str)

# 关闭打开的文件
f.close()




3）readline() 从文件中读取单独的一行。如果返回一个空字符串, 说明已经已经读取到最后一行。
f = open("/tmp/foo.txt", "r")

print(f.readline())
print(f.readline()) #返回第二行内容

# 关闭打开的文件
f.close()




4）readlines() 以列表形式返回该文件中包含的所有行。
f = open("/tmp/foo.txt", "r")

str = f.readlines()
print(str) #['name \n','this is ggg \n'] （注：其中换行的地方会加入\n）

# 关闭打开的文件
f.close()





5）write(string) 将 string 写入到文件中, 然后返回写入的字符数。
如果要写入一些不是字符串的东西, 那么将需要先转换成字符串形式
f = open("/tmp/foo.txt", "w")

num = f.write( "Python 是一个非常好的语言。\n是的，的确非常好!!\n" )
print(num) #29
# 关闭打开的文件
f.close()




6）flush() 用来刷新缓冲区，即将缓冲区中的数据立刻写入文件，同时清空缓冲区，不需要是被动的等待输出缓冲区写入。
一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法。
f = open("runoob.txt", "wb")
print ("文件名为: ", f.name)

# 刷新缓冲区
f.flush()

# 关闭文件
f.close()





7）isatty() 检测文件是否连接到一个终端设备，如果是返回 True，否则返回 False。
fo = open("runoob.txt", "wb")

ret = fo.isatty()
print ("返回值 : ", ret)

# 关闭文件
fo.close()




8）next() next()方法会在每次循环中调用，该方法返回文件的下一行，如果到达结尾(EOF),则触发 StopIteration
fo = open("runoob.txt", "r")

for index in range(5):
    line = next(fo)
    print ("第 %d 行 - %s" % (index, line)) 或者 print("第 {0} 行 - {1}".format(index, line))

# 关闭文件
fo.close()
结果：
第 0 行 - 这是第一行

第 1 行 - 这是第二行

第 2 行 - 这是第三行

第 3 行 - 这是第四行

第 4 行 - 这是第五行




9）seek()用于移动文件读取指针到指定位置。
参数
offset -- 开始的偏移量，也就是代表需要移动偏移的字节数
whence：可选，默认值为 0。表示从哪个位置开始偏移；
0代表从文件开头开始算起，1代表从当前位置开始算起，2代表从文件末尾算起。
f = open("test.txt")

print(f.readline()) #这是第一行
f.seek(0,0)
print(f.readline()) #这是第一行




10）tell() 返回文件的当前位置。
文件 runoob.txt 的内容如下：
1:www.runoob.com
2:www.runoob.com
3:www.runoob.com
4:www.runoob.com
5:www.runoob.com
fo = open("runoob.txt", "r+")

line = fo.readline()
print ("读取的数据为: %s" % (line))

# 获取当前文件位置
pos = fo.tell()
print ("当前位置: %d" % (pos))

# 关闭文件
fo.close()
以上实例输出结果为：
读取的数据为: 1:www.runoob.com
当前位置: 17




11）truncate(size) 用于从文件的首行首字符开始至size长度截断，后面的内容全部删除，无 size 表示从当前位置截断
其中 Widnows 系统下的换行代表2个字符大小。
该方法没有返回值。
fo = open("runoob.txt", "r+")

# 截取28个字节
fo.truncate(28)

str = fo.read()
print ("读取数据: %s" % (str))

# 关闭文件
fo.close()
读取数据: 1:www.runoob.com
2:www.runo




12）writelines(seq) 用于向文件中写入一序列的字符串。
这一序列字符串可以是由迭代对象产生的，如一个字符串列表。换行需要制定换行符 \n。
f = open('test.txt','w')
seq = ['a\n','b\n','c\n'] 或 seq = ('a\n','b\n','c\n')
f.writelines( seq )
f.close()
查看文件内容：
a
b
c























